node.js是基于v8引擎运行js的环境，它不是一门语言，你可以把他理解为谷歌浏览器，它是工具
为什么把node称之为后台语言？
客户端想服务器端发送请求，服务器端需要编写相关的程序，把客户端请求的内容准备好，然后返回给客户端
我们可以使用java/php等语言编写这些程序，也同样可以使用js编写这些操作（js是全栈编程语言，它可以写后台的程序了）
js代码写完后，我们要把它运行，此时我们在服务器上安装一个node工具，使用node可以把这些代码执行，从而让其具备相关的功能即可

安装node.js
默认情况下node安装成功后，会把相关的操作命令集成到系统的dos命令中（MAC是终端），以后我们可以在DOS（终端）命令中执行node的命令
node.js的基础知识
基于node环境使用js编写后台程序，相对于传统的后台语言具备了一些优势
基于V8引擎渲染解析代码（快）
基于事件驱动的非阻塞I/O操作
采用的是异步单线程开发
npm包管理器，是全球最大的开源库生态系统：https://www.npmjs.com/
对于前端开发工程师来说，学习成本低，可以快速入手这门技术
【NODE中的模块】
node其实就是由很多模块拼起来的
内置模块：node环境本身自带的（类似于浏览器也会天生自带一些自己的方法）
自定义模块：开发者自己编写的
第三方模块：别人写好的模块，我们可以下载下来使用（类似于在客户端导入JQ）
我们需要使用的第三方模块，在npmjs.com中都可以获取到；而模块的下载安装统一使用npm包管理器完成；
【NPM以及第三方模块】
npm install xxx -g 把模块安装在全局环境下
npm install --global xxx
浏览器中的全局对象是Window，NODE中的全局对象是global
npm install xxx 把模块安装在当前操作的项目目录下
npm install xxx --save-dev 不仅安装在当前下，并且把安装的信息记录在项目的packge.json清单中，生成一条开发环境依赖项
npm install xxx --save 和上述操作类似，不过生成的是一条生产环境依赖项
npm uninstall xxx -g/--save-dev/--save相当于安装来说，当前操作为卸载这些模块
npm install jquery@1.11.3 不仅安装了这个模块，指定了安装的版本号
...
1、安装在全局和安装在本地项目中的区别
安装在全局下，会在安装的全局目录中生成一个文件lessc.cmd->可以在DOS中执行命令的文件，此时我们就可以在DOS中执行 lessc这个命令了
安装在全局环境下的模块可以使用命令来操作，但是只能使用命令操作，如果想把这个安装的模块导入到我们自己的JS代码中使用，则是不可以的
安装在项目中
npm install less
安装完成后在当前的项目目录下多了一个文件夹：node_moduless，此文件夹中包含了我们安装的less模块
安装在本地项目中的模块无法使用命令来操作（默认情况下）；但是可以在当前项目的JS代码中，通过require把它导入进来，然后在js代码中调取模块中的方法，实现一些特殊的处理；
2、能否有办法技能使用命令也能导入到JS中？
真实项目开发的时候，我们很少安装在全局，因为安装在全局可能导致版本的冲突，一般我们都安装在本地项目中
在本地项目中配置模块的运行命令
npm init -y
在本地项目中生成一个package.json文件：项目的配置文件（命令中不加-y，需要自己在执行的时候一个个的输入配置信息，加-y一切都走默认的信息，比较方便快速）
在生成的package.json文件中的script属性中，配置我们需要运行的命令

配置完成后，接下来在当前项目的DOS命令中执行：npm run lessc


3、生产环境和开发环境
开发环境：项目在本地开发的时候，所需要依赖的模块叫做开发依赖项
生产环境：项目开发完成部署到服务器上，所需要依赖的模块叫做生产环境依赖项目
less模块，开发的时候需要依赖，项目部署后不需要依赖；开发的时候需要安装less模块，项目上线则不需要安装；

npm install less --save-dev 安装less模块并且把安装的信息存放在开发依赖项中

npm install less --save 安装less模块并且把安装的信息存放在生产依赖项中

为啥要设置依赖性？
项目如果是多人开发，我们使用git仓库来管理项目代码以及实现团队协作开发
A是其中的一个开发人员，开发这个项目需要的模块都安装在本地项目中了（node_modules）
A在提交自己的代码到git仓库的时候，会忽略node_modules文件夹的提交：因为这个文件中的内容太大了（当前项目增加.gitignore文件）
B从git仓库下载代码，代码都有了，但是开发需要依赖的模块没有，项目无法运行，此时B也需要安装这些模块，
1）找到A，手动记录一下需要的模块，然后B自己在本地一个个的安装（太low了）
2）此时体现出我们配置依赖项的好处了，A在他本地安装的时候，把安装的信息都记录到package.json的devDependencies/dependencies这里面，虽然node_modules没有传递到git仓库中，但是package.json中可以看到需要依赖的模块信息，此时的B只需要执行：npm install命令，就可以把当前项目需要依赖的模块自动的都安装上，我们把这个操作叫做‘跑环境’

4、安装指定版本的模块
查询当前模块的版本号
npm view webpack 查看webpack的版本号
npm view webpack > version.webpack由于查看版本号的时候信息太多，命令窗口中可能放不下，此时我们把查看的信息放在version.webpack这个文件中（文件名可以自己定义，不定义叫做version.webpack）
npm install webpack@1.15.0 --save-dev安装指定版本的模块


【NODE中的自定义模块】
在拿JS写后台（基于NODE环境）的时候，我们在项目中创建某一个JS文件来实现后台的一些业务逻辑处理，此时新创建的JS被称为一个‘自定义模块’
模块和模块之间是独立的，里面的方法不会产生冲突，当然也可以基于NODE提供的一些语法，实现模块与模块之间的调用
1、在当前模块中引入其它模块，从而调用其他模块中的方法‘require’
require（‘xxx’）导入某个模块，但是这样写是导入已经按照的第三方模块或者导入NODE内置的模块，这样写完后，它首先会到本地项目的node_modules中查找这个模块，如果有就是已经安装的第三方模块，如果没有继续查找NODE的内置模块，如果在没有就会报错
require（'./xxx'）或者require（'./xxx'）或者require（./stu/xxx）...这类模块都是属于引入模块的时候指定了了路径，此时他们的意思是导入自定义的模块（需要注意的是：路径地址一定要指定好）
/当前项目的跟目录
./当前目录
../上一级目录

let temp=require('./TEST1')
我们导入模块后，可以使用一个变量来接收它的返回值

module.exports
module是node环境中天生自带的一个对象，用来进行node模块管理的
它里面有一个对象叫做exports，把模块中的部分方法导出，提供给其他模块调取使用

2、在WS中配置语言提示包（基于NODE环境JS开发后程序需要的语言提示）

3、在NODE环境下执行JS代码
webpack
WS中的terminal也相当于dos命令（基于）

4、综合练习
有三个自定义模块：A、B、C
A中提供一个sum方法，实现任意数求和
B中提供一个avg方法，实现求一堆数的平均数（先求和，在求平均，求合需要用到A中的sum）
C中准备一些数字，调取B中的avg方法，获取到需要的平均数


【NODE中的内置模块】
当JS在NODE中运行的时候，NODE也会给JS提供一些内置的属性和方法，这些属性方法都存储在NODE的内置模块中
http
url
fs
...
《fs内置模块》
fs模块中提供了一些属性和方法供JS在服务器上进行I/O操作（input/output 输入/输出）：对文件的增删改查等处理
JS在客户端浏览器运行的时候，能否对客户端的本地文件进行I/O操作？
答：不能；如果可以的话，对客户端的电脑会造成极大的安全隐患；但是有些操作是可以的，例如上传文件或者图片（input type='file'），但是需要用户手动去选择本地文件上传；
JS在服务器的NODE中运行的时候，能否对服务器上的文件进行I/O操作？
答：能；FS模块中提供的方法就是让我们干这些事情的
let fs=require('fs');
  1.读取文件中内容
fs.readFile      异步读取某一个文件中的内容
fs.readFile([pathname],(error,value)=>{}
fs.readFileSync  同步读取某一个文件中的内容（相对于异步来说，同步操作是把内容读取完成后，才会执行后续的操作，而异步是读取过程中不管是否读取完成，都会去执行后续的操作）
let con=fs.readFileSync([pathname],[encode])

  2.向指定文件中写入内容
fs.writeFilte([pathname],[content],[encode],[callback])
fs.writeFilteSync([pathname],[content],[encode],[callback])
我们的内容写入是覆盖式的：新写入的内容会把之前的内容都覆盖掉（之前的内容都没有了）如果不想覆盖，先把之前的内容获取，和最新的内容进行拼接，把拼接后的结果整体写入进去，类似于xxx.innerHTML+=``

  3.读取文件夹目录
fs.readdir([pathname],(error,value)=>{
当查找完成后执行回调函数，value存储的值就是找到的全部文件目录信息（数组）});
fs.readdirSync([pathname])返回的结果是一个数组，包含当前目录下的文件列表信息

综合案例：自己编写一个模块，能够批量编译lessc文件，并且配置在项目的命令中


《url》


《HTTP内置模块》
作为后台开发工程师，我们需要创建一个服务用来你接收客户端请求，并且把需要的数据内容准备好，最后返回给客户端，而HTTP内置模块中提供了做这些事情的属性和方法

let http=require('http'),
    url=require('url'),
    fs=require('fs');
//->首先创建一个服务
let server=http.createServer(()=>{
    //->次回调函数并不是创建服务成功执行，而是客户端向当前服务器的这个服务（端口号1990这个服务）发送请求的时候，才会被触发执行，而且客户端发送几次请求，这个回调函数就会被触发执行几次
    /**
     * 如何向当前的服务发送请求
     * 都是基于浏览器来完成，在客户端浏览器的地址栏中输入
     * http：//localhost：1990/...（访问本机服务）
     * http：//192.168.1.114:80/..（局域网IP或者外网IP访问某台主机上的服务，真实项目中是通过域名访问的）
     */
    console.log('ok');
    //->回调函数在客户端请求的时候不仅被执行了，而且还传递了两个参数值；
    //req：request  对象，里面存储了客户端发送过来的全部请求信息，例如：req.url存储的就是当前客户端请求资源的路径名称以及传递的问号参数值
    //res：response对象，里面提供了很多的方法可以让服务器端把内容返回给客户端，例如：res.end（[content]）就是把指定的内容返回给客户端的浏览器
});
//->还需要给创建的服务安排一个端口号（一台服务器上可以能有很多的服务，需要使用端口号来区分）
server.listen(80,()=>{
    console.log('server is success, listening on 80 port!');
});
