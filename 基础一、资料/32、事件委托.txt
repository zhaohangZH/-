事件委托（事件代理）Event Delegation：

利用了事件的冒泡传播机制，我们给最外层容器的事件行为绑定一个方法，里面后代元素的事件行为不再绑定方法，这样我们操作的是后代元素，也同样会传播到外层容器上，绑定的方法也会执行，在这个方法中我们通过判断事件源是谁，来做不同的操作（当前元素的相关行为被触发，其所有父级元素的相关行为都会被触发，如果绑定了方法，对应的方法也会被执行[执行方法的时候也会把事件对象传播给对应的函数]）

通过事件对象中的事件源，我们可以清楚的知道当前操作的哪一个元素，也可以根据事件源的不同做不同的事情

利用上面的机制，如果我们一个容器中很多元素都要绑定点击事件，我们则不需要再一个个的绑定方法了，直接给最外层容器的点击事件绑定方法即可，这样不管点击的是哪一个后代元素，当前外层容器的click行为都会被触发，绑定的方法也会被执行；我们通过区分事件源来处理不同的事件即可...=>这样的处理机制所消耗的性能比一个个绑定消耗的性能减少50%左右（约等于值）

事件代理在真实项目中经常被应用 
1、一个容器中很多后代元素都要给某个事件行为绑定方法，此时就可以使用事件代理来操作了 
2、类似于操作xxx做什么，其余的做什么这样的需求基本上也是用事件委托 
3、元素是动态绑定的，需要给新绑定元素的某些行为绑定方法，一般也用事件委托 








