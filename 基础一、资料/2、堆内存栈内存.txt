堆内存
如果有变量（函数名）占用了堆内存的地址，那么当前的堆内存则不能释放
如果当前堆内存的地址，没有被任何的东西所引用，当前的堆内存就没用了，浏览器会在空闲的时候清理掉这些没用的堆内存（谷歌浏览器）

IE下的堆内存释放采用的是计数器机制，被一个变量占用，计数器累加1，如果之前的某个占用被移除，计数器减1；但是很多时候IE的计数器计数的时候出现问题，导致“内存泄漏”

var obj={name:'赵航'}；//->obj=xxfffooo此时的obj把堆内存占用了
obj=null；//->obj不占用堆内存了，浏览器在空闲的时候会销毁这个无用的堆内存
/*null：空对象指针，不指向任何的堆内存*/

栈内存（作用域）的释放
全局作用域，浏览器加载页面的时候形成全局作用域，在浏览器中把当前页面关闭的时候，全局作用域销毁
私有作用域：函数执行的时候会形成私有作用域，一般情况下，函数执行完成，形成的这个私有作用域立即释放销毁
特殊情况：当私有作用域中的某一个东西（一般指的都是私有作用域中开辟的那个堆内存）被作用域以外的变量给占用了，当前的私有作用域（栈内存）就不能销毁了；这个私有作用域不销毁，代表着它里面存储的私有变量也不会销毁了；
i++和++i的区别
都是在自身基础上累加1，不同地方在于和其它值运算的时候，累加1在前还是在后
var i=10；
console.log（5+i++）；//->先计算5+i，计算完成后再把i累加1  =>15 i=11
console.log（5+(i++)）;//->加上括号也是先运算在累加
i=10；
console.log（5+（++i））；//->先让i累加1，把累加后的结果和5进行运算  i=11  =>16


